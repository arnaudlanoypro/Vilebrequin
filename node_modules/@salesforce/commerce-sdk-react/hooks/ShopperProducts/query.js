"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useProducts = exports.useProduct = exports.useCategory = exports.useCategories = void 0;
var _useCommerceApi = _interopRequireDefault(require("../useCommerceApi"));
var _useQuery = require("../useQuery");
var _utils = require("../utils");
var queryKeyHelpers = _interopRequireWildcard(require("./queryKeyHelpers"));
var _paramKeys = _interopRequireDefault(require("./paramKeys"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } /*
 * Copyright (c) 2023, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/**
 * Allows access to multiple products by a single request. Only products that are online and assigned to a site catalog are returned. The maximum number of productIDs that can be requested are 24. Along with product details, the availability, product options, images, price, promotions, and variations for the valid products will be included, as appropriate.
 * @group ShopperProducts
 * @category Query
 * @parameter apiOptions - Options to pass through to `commerce-sdk-isomorphic`, with `null` accepted for unset API parameters.
 * @parameter queryOptions - TanStack Query query options, with `enabled` by default set to check that all required API parameters have been set.
 * @returns A TanStack Query query hook with data from the Shopper Products `getProducts` endpoint.
 * @see {@link https://developer.salesforce.com/docs/commerce/commerce-api/references/shopper-products?meta=getProducts| Salesforce Developer Center} for more information about the API endpoint.
 * @see {@link https://salesforcecommercecloud.github.io/commerce-sdk-isomorphic/classes/shopperproducts.shopperproducts-1.html#getproducts | `commerce-sdk-isomorphic` documentation} for more information on the parameters and returned data type.
 * @see {@link https://tanstack.com/query/latest/docs/react/reference/useQuery | TanStack Query `useQuery` reference} for more information about the return value.
 */
const useProducts = (apiOptions, queryOptions = {}) => {
  const {
    shopperProducts: client
  } = (0, _useCommerceApi.default)();
  const methodName = 'getProducts';
  const requiredParameters = ['organizationId', 'ids', 'siteId'];

  // Parameters can be set in `apiOptions` or `client.clientConfig`;
  // we must merge them in order to generate the correct query key.
  const netOptions = (0, _utils.omitNullableParameters)((0, _utils.mergeOptions)(client, apiOptions));
  // get param keys for the api from netOptions
  const paramKeys = [..._paramKeys.default[methodName], ...(0, _utils.getCustomKeys)(netOptions.parameters)];
  const parameters = (0, _utils.pick)(netOptions.parameters, paramKeys);
  const queryKey = queryKeyHelpers[methodName].queryKey(netOptions.parameters);
  // We don't use `netOptions` here because we manipulate the options in `useQuery`.
  const method = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (options) {
      return yield client[methodName](options);
    });
    return function method(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  // For some reason, if we don't explicitly set these generic parameters, the inferred type for
  // `Data` sometimes, but not always, includes `Response`, which is incorrect. I don't know why.
  return (0, _useQuery.useQuery)(_objectSpread(_objectSpread({}, netOptions), {}, {
    parameters
  }), queryOptions, {
    method,
    queryKey,
    requiredParameters
  });
};
/**
 * Allows access to product details for a single product ID. Only products that are online and assigned to a site catalog are returned. Along with product details, the availability, images, price, bundled_products, set_products, recommedations, product options, variations, and promotions for the products will be included, as appropriate.
 * @group ShopperProducts
 * @category Query
 * @parameter apiOptions - Options to pass through to `commerce-sdk-isomorphic`, with `null` accepted for unset API parameters.
 * @parameter queryOptions - TanStack Query query options, with `enabled` by default set to check that all required API parameters have been set.
 * @returns A TanStack Query query hook with data from the Shopper Products `getProduct` endpoint.
 * @see {@link https://developer.salesforce.com/docs/commerce/commerce-api/references/shopper-products?meta=getProduct| Salesforce Developer Center} for more information about the API endpoint.
 * @see {@link https://salesforcecommercecloud.github.io/commerce-sdk-isomorphic/classes/shopperproducts.shopperproducts-1.html#getproduct | `commerce-sdk-isomorphic` documentation} for more information on the parameters and returned data type.
 * @see {@link https://tanstack.com/query/latest/docs/react/reference/useQuery | TanStack Query `useQuery` reference} for more information about the return value.
 */
exports.useProducts = useProducts;
const useProduct = (apiOptions, queryOptions = {}) => {
  const {
    shopperProducts: client
  } = (0, _useCommerceApi.default)();
  const methodName = 'getProduct';
  const requiredParameters = ['organizationId', 'id', 'siteId'];

  // Parameters can be set in `apiOptions` or `client.clientConfig`;
  // we must merge them in order to generate the correct query key.
  const netOptions = (0, _utils.omitNullableParameters)((0, _utils.mergeOptions)(client, apiOptions));
  // get param keys for the api from netOptions
  const paramKeys = [..._paramKeys.default[methodName], ...(0, _utils.getCustomKeys)(netOptions.parameters)];
  const parameters = (0, _utils.pick)(netOptions.parameters, paramKeys);
  const queryKey = queryKeyHelpers[methodName].queryKey(netOptions.parameters);
  // We don't use `netOptions` here because we manipulate the options in `useQuery`.
  const method = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (options) {
      return yield client[methodName](options);
    });
    return function method(_x2) {
      return _ref2.apply(this, arguments);
    };
  }();

  // For some reason, if we don't explicitly set these generic parameters, the inferred type for
  // `Data` sometimes, but not always, includes `Response`, which is incorrect. I don't know why.
  return (0, _useQuery.useQuery)(_objectSpread(_objectSpread({}, netOptions), {}, {
    parameters
  }), queryOptions, {
    method,
    queryKey,
    requiredParameters
  });
};
/**
 * When you use the URL template, the server returns multiple categories (a result object of category documents). You can use this template as a convenient way of obtaining multiple categories in a single request, instead of issuing separate requests for each category. You can specify up to 50 multiple IDs. You must enclose the list of IDs in parentheses. If a category identifier contains parenthesis or the separator sign, you must URL encode the character. The server only returns online categories.
 * @group ShopperProducts
 * @category Query
 * @parameter apiOptions - Options to pass through to `commerce-sdk-isomorphic`, with `null` accepted for unset API parameters.
 * @parameter queryOptions - TanStack Query query options, with `enabled` by default set to check that all required API parameters have been set.
 * @returns A TanStack Query query hook with data from the Shopper Products `getCategories` endpoint.
 * @see {@link https://developer.salesforce.com/docs/commerce/commerce-api/references/shopper-products?meta=getCategories| Salesforce Developer Center} for more information about the API endpoint.
 * @see {@link https://salesforcecommercecloud.github.io/commerce-sdk-isomorphic/classes/shopperproducts.shopperproducts-1.html#getcategories | `commerce-sdk-isomorphic` documentation} for more information on the parameters and returned data type.
 * @see {@link https://tanstack.com/query/latest/docs/react/reference/useQuery | TanStack Query `useQuery` reference} for more information about the return value.
 */
exports.useProduct = useProduct;
const useCategories = (apiOptions, queryOptions = {}) => {
  const {
    shopperProducts: client
  } = (0, _useCommerceApi.default)();
  const methodName = 'getCategories';
  const requiredParameters = ['organizationId', 'ids', 'siteId'];

  // Parameters can be set in `apiOptions` or `client.clientConfig`;
  // we must merge them in order to generate the correct query key.
  const netOptions = (0, _utils.omitNullableParameters)((0, _utils.mergeOptions)(client, apiOptions));
  // get param keys for the api from netOptions
  const paramKeys = [..._paramKeys.default[methodName], ...(0, _utils.getCustomKeys)(netOptions.parameters)];
  const parameters = (0, _utils.pick)(netOptions.parameters, paramKeys);
  const queryKey = queryKeyHelpers[methodName].queryKey(netOptions.parameters);
  // We don't use `netOptions` here because we manipulate the options in `useQuery`.
  const method = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(function* (options) {
      return yield client[methodName](options);
    });
    return function method(_x3) {
      return _ref3.apply(this, arguments);
    };
  }();

  // For some reason, if we don't explicitly set these generic parameters, the inferred type for
  // `Data` sometimes, but not always, includes `Response`, which is incorrect. I don't know why.
  return (0, _useQuery.useQuery)(_objectSpread(_objectSpread({}, netOptions), {}, {
    parameters
  }), queryOptions, {
    method,
    queryKey,
    requiredParameters
  });
};
/**
 * When you use the URL template below, the server returns a category identified by its ID; by default, the server
also returns the first level of subcategories, but you can specify another level by setting the levels
parameter. The server only returns online categories.
 * @group ShopperProducts
 * @category Query
 * @parameter apiOptions - Options to pass through to `commerce-sdk-isomorphic`, with `null` accepted for unset API parameters.
 * @parameter queryOptions - TanStack Query query options, with `enabled` by default set to check that all required API parameters have been set.
 * @returns A TanStack Query query hook with data from the Shopper Products `getCategory` endpoint.
 * @see {@link https://developer.salesforce.com/docs/commerce/commerce-api/references/shopper-products?meta=getCategory| Salesforce Developer Center} for more information about the API endpoint.
 * @see {@link https://salesforcecommercecloud.github.io/commerce-sdk-isomorphic/classes/shopperproducts.shopperproducts-1.html#getcategory | `commerce-sdk-isomorphic` documentation} for more information on the parameters and returned data type.
 * @see {@link https://tanstack.com/query/latest/docs/react/reference/useQuery | TanStack Query `useQuery` reference} for more information about the return value.
 */
exports.useCategories = useCategories;
const useCategory = (apiOptions, queryOptions = {}) => {
  const {
    shopperProducts: client
  } = (0, _useCommerceApi.default)();
  const methodName = 'getCategory';
  const requiredParameters = ['organizationId', 'id', 'siteId'];

  // Parameters can be set in `apiOptions` or `client.clientConfig`;
  // we must merge them in order to generate the correct query key.
  const netOptions = (0, _utils.omitNullableParameters)((0, _utils.mergeOptions)(client, apiOptions));
  // get param keys for the api from netOptions
  const paramKeys = [..._paramKeys.default[methodName], ...(0, _utils.getCustomKeys)(netOptions.parameters)];
  const parameters = (0, _utils.pick)(netOptions.parameters, paramKeys);
  const queryKey = queryKeyHelpers[methodName].queryKey(netOptions.parameters);
  // We don't use `netOptions` here because we manipulate the options in `useQuery`.
  const method = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(function* (options) {
      return yield client[methodName](options);
    });
    return function method(_x4) {
      return _ref4.apply(this, arguments);
    };
  }();

  // For some reason, if we don't explicitly set these generic parameters, the inferred type for
  // `Data` sometimes, but not always, includes `Response`, which is incorrect. I don't know why.
  return (0, _useQuery.useQuery)(_objectSpread(_objectSpread({}, netOptions), {}, {
    parameters
  }), queryOptions, {
    method,
    queryKey,
    requiredParameters
  });
};
exports.useCategory = useCategory;