"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _commerceSdkIsomorphic = require("commerce-sdk-isomorphic");
var _jwtDecode = require("jwt-decode");
var _storage = require("./storage");
var _utils = require("../utils");
var _constant = require("../constant");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } /*
 * Copyright (c) 2023, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/**
 * The extended field is not from api response, we manually store the auth type,
 * so we don't need to make another API call when we already have the data.
 * Plus, the getCustomer endpoint only works for registered user, it returns a 404 for a guest user,
 * and it's not easy to grab this info in user land, so we add it into the Auth object, and expose it via a hook
 */

/** A shopper could be guest or registered, so we store the refresh tokens individually. */

const isParentTrusted = (0, _utils.isOriginTrusted)((0, _utils.getParentOrigin)());

/**
 * A map of the data that this auth module stores. This maps the name of the property to
 * the storage type and the key when stored in that storage. You can also pass in a "callback"
 * function to do extra operation after a property is set.
 */
const DATA_MAP = {
  access_token: {
    storageType: 'local',
    key: 'access_token'
  },
  customer_id: {
    storageType: 'local',
    key: 'customer_id'
  },
  usid: {
    storageType: 'cookie',
    key: 'usid'
  },
  enc_user_id: {
    storageType: 'local',
    key: 'enc_user_id'
  },
  expires_in: {
    storageType: 'local',
    key: 'expires_in'
  },
  id_token: {
    storageType: 'local',
    key: 'id_token'
  },
  idp_access_token: {
    storageType: 'local',
    key: 'idp_access_token'
  },
  token_type: {
    storageType: 'local',
    key: 'token_type'
  },
  refresh_token_guest: {
    storageType: 'cookie',
    key: isParentTrusted ? 'cc-nx-g-iframe' : 'cc-nx-g',
    callback: store => {
      store.delete(isParentTrusted ? 'cc-nx-iframe' : 'cc-nx');
    }
  },
  refresh_token_registered: {
    storageType: 'cookie',
    key: isParentTrusted ? 'cc-nx-iframe' : 'cc-nx',
    callback: store => {
      store.delete(isParentTrusted ? 'cc-nx-g-iframe' : 'cc-nx-g');
    }
  },
  refresh_token_expires_in: {
    storageType: 'local',
    key: 'refresh_token_expires_in'
  },
  customer_type: {
    storageType: 'local',
    key: 'customer_type'
  },
  /*
   * For Hybrid setups, we need a mechanism to inform PWA Kit whenever customer login state changes on SFRA.
   * We do this by having SFRA store the access token in cookies. If these cookies are present, PWA
   * compares the access token from the cookie with the one in local store. If the tokens are different,
   * discard the access token in local store and replace it with the access token from the cookie.
   *
   * ECOM has a 1200 character limit on the values of cookies. The access token easily exceeds this amount
   * so it sends the access token in chunks across several cookies.
   *
   * The JWT tends to come in at around 2250 characters so there's usually
   * both a cc-at and cc-at_2.
   */
  access_token_sfra: {
    storageType: 'cookie',
    key: 'cc-at'
  }
};

/**
 * This class is used to handle shopper authentication.
 * It is responsible for initializing shopper session, manage access
 * and refresh tokens on server/browser environments. As well as providing
 * a mechanism to queue network calls before having a valid access token.
 *
 * @Internal
 */
class Auth {
  constructor(config) {
    // Special endpoint for injecting SLAS private client secret
    const baseUrl = config.proxy.split(`/mobify/proxy/api`)[0];
    const privateClientEndpoint = `${baseUrl}/mobify/slas/private`;
    this.client = new _commerceSdkIsomorphic.ShopperLogin({
      proxy: config.enablePWAKitPrivateClient ? privateClientEndpoint : config.proxy,
      parameters: {
        clientId: config.clientId,
        organizationId: config.organizationId,
        shortCode: config.shortCode,
        siteId: config.siteId
      },
      throwOnBadResponse: true,
      fetchOptions: config.fetchOptions
    });
    this.shopperCustomersClient = new _commerceSdkIsomorphic.ShopperCustomers({
      proxy: config.proxy,
      parameters: {
        clientId: config.clientId,
        organizationId: config.organizationId,
        shortCode: config.shortCode,
        siteId: config.siteId
      },
      throwOnBadResponse: true,
      fetchOptions: config.fetchOptions
    });
    const options = {
      keySuffix: config.siteId,
      // Setting this to true on the server allows us to reuse guest auth tokens across lambda runs
      sharedContext: !(0, _utils.onClient)()
    };
    this.stores = {
      cookie: (0, _utils.onClient)() ? new _storage.CookieStorage(options) : new _storage.MemoryStorage(options),
      local: (0, _utils.onClient)() ? new _storage.LocalStorage(options) : new _storage.MemoryStorage(options),
      memory: new _storage.MemoryStorage(options)
    };
    this.redirectURI = config.redirectURI;
    this.fetchedToken = config.fetchedToken || '';
    this.OCAPISessionsURL = config.OCAPISessionsURL || '';

    /*
     * There are 2 ways to enable SLAS private client mode.
     * If enablePWAKitPrivateClient=true, we route SLAS calls to /mobify/slas/private
     * and set an internal placeholder as the client secret. The proxy will override the placeholder
     * with the actual client secret so any truthy value as the placeholder works here.
     *
     * If enablePWAKitPrivateClient=false and clientSecret is provided as a non-empty string,
     * private client mode is enabled but we don't route calls to /mobify/slas/private
     * This is how non-PWA Kit consumers of commerce-sdk-react can enable private client and set a secret
     *
     * If both enablePWAKitPrivateClient and clientSecret are truthy, enablePWAKitPrivateClient takes
     * priority and we ignore whatever was set for clientSecret. This prints a warning about the clientSecret
     * being ignored.
     *
     * If both enablePWAKitPrivateClient and clientSecret are falsey, we are in SLAS public client mode.
     */
    if (config.enablePWAKitPrivateClient && config.clientSecret) {
      this.logWarning(_constant.SLAS_SECRET_OVERRIDE_MSG);
    }
    this.clientSecret = config.enablePWAKitPrivateClient ?
    // PWA proxy is enabled, assume project is PWA and that the proxy will handle setting the secret
    // We can pass any truthy value here to satisfy commerce-sdk-isomorphic requirements
    _constant.SLAS_SECRET_PLACEHOLDER :
    // We think there are users of Commerce SDK React and Commerce SDK isomorphic outside of PWA
    // For these users to use a private client, they must have some way to set a client secret
    // PWA users should not need to touch this.
    config.clientSecret || '';
    this.silenceWarnings = config.silenceWarnings || false;
  }
  get(name) {
    const {
      key,
      storageType
    } = DATA_MAP[name];
    const storage = this.stores[storageType];
    return storage.get(key);
  }
  set(name, value, options) {
    var _DATA_MAP$name$callba, _DATA_MAP$name;
    const {
      key,
      storageType
    } = DATA_MAP[name];
    const storage = this.stores[storageType];
    storage.set(key, value, options);
    (_DATA_MAP$name$callba = (_DATA_MAP$name = DATA_MAP[name]).callback) === null || _DATA_MAP$name$callba === void 0 ? void 0 : _DATA_MAP$name$callba.call(_DATA_MAP$name, storage);
  }
  clearStorage() {
    // Type assertion because Object.keys is silly and limited :(
    const keys = Object.keys(DATA_MAP);
    keys.forEach(keyName => {
      const {
        key,
        storageType
      } = DATA_MAP[keyName];
      const store = this.stores[storageType];
      store.delete(key);
    });
  }

  /**
   * Every method in this class that returns a `TokenResponse` constructs it via this getter.
   */
  get data() {
    return {
      access_token: this.get('access_token'),
      customer_id: this.get('customer_id'),
      enc_user_id: this.get('enc_user_id'),
      expires_in: parseInt(this.get('expires_in')),
      id_token: this.get('id_token'),
      idp_access_token: this.get('idp_access_token'),
      refresh_token: this.get('refresh_token_registered') || this.get('refresh_token_guest'),
      token_type: this.get('token_type'),
      usid: this.get('usid'),
      customer_type: this.get('customer_type'),
      refresh_token_expires_in: this.get('refresh_token_expires_in')
    };
  }

  /**
   * Used to validate JWT token expiration.
   */
  isTokenExpired(token) {
    const {
      exp,
      iat
    } = (0, _jwtDecode.jwtDecode)(token.replace('Bearer ', ''));
    const validTimeSeconds = exp - iat - 60;
    const tokenAgeSeconds = Date.now() / 1000 - iat;
    return validTimeSeconds <= tokenAgeSeconds;
  }

  /**
   * Returns the SLAS access token or an empty string if the access token
   * is not found in local store or if SFRA wants PWA to trigger refresh token login.
   *
   * On PWA-only sites, this returns the access token from local storage.
   * On Hybrid sites, this checks whether SFRA has sent an auth token via cookies.
   * Returns an access token from SFRA if it exist.
   * If not, the access token from local store is returned.
   *
   * This is only used within this Auth module since other modules consider the access
   * token from this.get('access_token') to be the source of truth.
   *
   * @returns {string} access token
   */
  getAccessToken() {
    let accessToken = this.get('access_token');
    const sfraAuthToken = this.get('access_token_sfra');
    if (sfraAuthToken) {
      /*
       * If SFRA sends 'refresh', we return an empty token here so PWA can trigger a login refresh
       * This key is used when logout is triggered in SFRA but the redirect after logout
       * sends the user to PWA.
       */
      if (sfraAuthToken === 'refresh') {
        this.set('access_token', '');
        this.clearSFRAAuthToken();
        return '';
      }
      const {
        isGuest,
        customerId,
        usid
      } = this.parseSlasJWT(sfraAuthToken);
      this.set('access_token', sfraAuthToken);
      this.set('customer_id', customerId);
      this.set('usid', usid);
      this.set('customer_type', isGuest ? 'guest' : 'registered');
      accessToken = sfraAuthToken;
      // SFRA -> PWA access token cookie handoff is succesful so we clear the SFRA made cookies.
      // We don't want these cookies to persist and continue overriding what is in local store.
      this.clearSFRAAuthToken();
    }
    return accessToken;
  }
  clearSFRAAuthToken() {
    const {
      key,
      storageType
    } = DATA_MAP['access_token_sfra'];
    const store = this.stores[storageType];
    store.delete(key);
  }

  /**
   * This method stores the TokenResponse object retrived from SLAS, and
   * store the data in storage.
   */
  handleTokenResponse(res, isGuest) {
    this.set('access_token', res.access_token);
    this.set('customer_id', res.customer_id);
    this.set('enc_user_id', res.enc_user_id);
    this.set('expires_in', `${res.expires_in}`);
    this.set('id_token', res.id_token);
    this.set('idp_access_token', res.idp_access_token);
    this.set('token_type', res.token_type);
    this.set('usid', res.usid);
    this.set('customer_type', isGuest ? 'guest' : 'registered');
    const refreshTokenKey = isGuest ? 'refresh_token_guest' : 'refresh_token_registered';
    this.set(refreshTokenKey, res.refresh_token, {
      expires: res.refresh_token_expires_in
    });
  }

  /**
   * This method queues the requests and handles the SLAS token response.
   *
   * It returns the queue.
   *
   * @Internal
   */
  queueRequest(fn, isGuest) {
    var _this = this;
    return _asyncToGenerator(function* () {
      const queue = _this.pendingToken ?? Promise.resolve();
      _this.pendingToken = queue.then( /*#__PURE__*/_asyncToGenerator(function* () {
        const token = yield fn();
        _this.handleTokenResponse(token, isGuest);
        if ((0, _utils.onClient)() && _this.OCAPISessionsURL) {
          void _this.createOCAPISession();
        }
        // Q: Why don't we just return token? Why re-construct the same object again?
        // A: because a user could open multiple tabs and the data in memory could be out-dated
        // We must always grab the data from the storage (cookie/localstorage) directly
        return _this.data;
      })).finally(() => {
        _this.pendingToken = undefined;
      });
      return yield _this.pendingToken;
    })();
  }
  logWarning = msg => {
    if (!this.silenceWarnings) {
      console.warn(msg);
    }
  };

  /**
   * The ready function returns a promise that resolves with valid ShopperLogin
   * token response.
   *
   * When this method is called for the very first time, it initializes the session
   * by following the public client auth flow to get access token for the user.
   * The flow:
   * 1. If we have valid access token - use it
   * 2. If we have valid refresh token - refresh token flow
   * 3. PKCE flow
   */
  ready() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      if (_this2.fetchedToken && _this2.fetchedToken !== '') {
        const {
          isGuest,
          customerId,
          usid
        } = _this2.parseSlasJWT(_this2.fetchedToken);
        _this2.set('access_token', _this2.fetchedToken);
        _this2.set('customer_id', customerId);
        _this2.set('usid', usid);
        _this2.set('customer_type', isGuest ? 'guest' : 'registered');
        return _this2.data;
      }
      if (_this2.pendingToken) {
        return yield _this2.pendingToken;
      }
      const accessToken = _this2.getAccessToken();
      if (accessToken && !_this2.isTokenExpired(accessToken)) {
        return _this2.data;
      }
      const refreshTokenRegistered = _this2.get('refresh_token_registered');
      const refreshTokenGuest = _this2.get('refresh_token_guest');
      const refreshToken = refreshTokenRegistered || refreshTokenGuest;
      if (refreshToken) {
        try {
          return yield _this2.queueRequest(() => _commerceSdkIsomorphic.helpers.refreshAccessToken(_this2.client, {
            refreshToken
          }, {
            clientSecret: _this2.clientSecret
          }), !!refreshTokenGuest);
        } catch (error) {
          // If the refresh token is invalid, we need to re-login the user
          if (error instanceof Error && 'response' in error) {
            // commerce-sdk-isomorphic throws a `ResponseError`, but doesn't export the class.
            // We can't use `instanceof`, so instead we just check for the `response` property
            // and assume it is a fetch Response.
            const json = yield error['response'].json();
            if (json.message === 'invalid refresh_token') {
              // clean up storage and restart the login flow
              _this2.clearStorage();
            }
          }
        }
      }
      return _this2.loginGuestUser();
    })();
  }

  /**
   * Creates a function that only executes after a session is initialized.
   * @param fn Function that needs to wait until the session is initialized.
   * @returns Wrapped function
   */
  whenReady(fn) {
    var _this3 = this;
    return /*#__PURE__*/_asyncToGenerator(function* (...args) {
      yield _this3.ready();
      return yield fn(...args);
    });
  }

  /**
   * A wrapper method for commerce-sdk-isomorphic helper: loginGuestUser.
   *
   */
  loginGuestUser() {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      if (_this4.clientSecret && (0, _utils.onClient)() && _this4.clientSecret !== _constant.SLAS_SECRET_PLACEHOLDER) {
        _this4.logWarning(_constant.SLAS_SECRET_WARNING_MSG);
      }
      const usid = _this4.get('usid');
      const isGuest = true;
      const guestPrivateArgs = [_this4.client, _objectSpread({}, usid && {
        usid
      }), {
        clientSecret: _this4.clientSecret
      }];
      const guestPublicArgs = [_this4.client, _objectSpread({
        redirectURI: _this4.redirectURI
      }, usid && {
        usid
      })];
      const callback = _this4.clientSecret ? () => _commerceSdkIsomorphic.helpers.loginGuestUserPrivate(...guestPrivateArgs) : () => _commerceSdkIsomorphic.helpers.loginGuestUser(...guestPublicArgs);
      return yield _this4.queueRequest(callback, isGuest);
    })();
  }

  /**
   * This is a wrapper method for ShopperCustomer API registerCustomer endpoint.
   *
   */
  register(body) {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      const {
        customer: {
          login
        },
        password
      } = body;

      // login is optional field from isomorphic library
      // type CustomerRegistration
      // here we had to guard it to avoid ts error
      if (!login) {
        throw new Error('Customer registration is missing login field.');
      }
      const res = yield _this5.shopperCustomersClient.registerCustomer({
        headers: {
          authorization: `Bearer ${_this5.get('access_token')}`
        },
        body
      });
      yield _this5.loginRegisteredUserB2C({
        username: login,
        password
      });
      return res;
    })();
  }

  /**
   * A wrapper method for commerce-sdk-isomorphic helper: loginRegisteredUserB2C.
   *
   */
  loginRegisteredUserB2C(credentials) {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      if (_this6.clientSecret && (0, _utils.onClient)() && _this6.clientSecret !== _constant.SLAS_SECRET_PLACEHOLDER) {
        _this6.logWarning(_constant.SLAS_SECRET_WARNING_MSG);
      }
      const redirectURI = _this6.redirectURI;
      const usid = _this6.get('usid');
      const isGuest = false;
      const token = yield _commerceSdkIsomorphic.helpers.loginRegisteredUserB2C(_this6.client, _objectSpread(_objectSpread({}, credentials), {}, {
        clientSecret: _this6.clientSecret
      }), _objectSpread({
        redirectURI
      }, usid && {
        usid
      }));
      _this6.handleTokenResponse(token, isGuest);
      if ((0, _utils.onClient)() && _this6.OCAPISessionsURL) {
        void _this6.createOCAPISession();
      }
      return token;
    })();
  }

  /**
   * A wrapper method for commerce-sdk-isomorphic helper: logout.
   *
   */
  logout() {
    var _this7 = this;
    return _asyncToGenerator(function* () {
      // Not awaiting on purpose because there isn't much we can do if this fails.
      void _commerceSdkIsomorphic.helpers.logout(_this7.client, {
        accessToken: _this7.get('access_token'),
        refreshToken: _this7.get('refresh_token_registered')
      });
      _this7.clearStorage();
      return yield _this7.loginGuestUser();
    })();
  }

  /**
   * Make a post request to the OCAPI /session endpoint to bridge the session.
   *
   * The HTTP response contains a set-cookie header which sets the dwsid session cookie.
   * This cookie is used on SFRA, and it allows shoppers to navigate between SFRA and
   * this PWA site seamlessly; this is often used to enable hybrid deployment.
   *
   * (Note: this method is client side only, b/c MRT doesn't support set-cookie header right now)
   *
   * @returns {Promise}
   */
  createOCAPISession() {
    return fetch(this.OCAPISessionsURL, {
      method: 'POST',
      headers: {
        Authorization: 'Bearer ' + this.get('access_token')
      }
    });
  }

  /**
   * Decode SLAS JWT and extract information such as customer id, usid, etc.
   *
   */
  parseSlasJWT(jwt) {
    const payload = (0, _jwtDecode.jwtDecode)(jwt);
    const {
      sub,
      isb
    } = payload;
    if (!sub || !isb) {
      throw new Error('Unable to parse access token payload: missing sub and isb.');
    }

    // ISB format
    // 'uido:ecom::upn:Guest||xxxEmailxxx::uidn:FirstName LastName::gcid:xxxGuestCustomerIdxxx::rcid:xxxRegisteredCustomerIdxxx::chid:xxxSiteIdxxx',
    const isbParts = isb.split('::');
    const isGuest = isbParts[1] === 'upn:Guest';
    const customerId = isGuest ? isbParts[3].replace('gcid:', '') : isbParts[4].replace('rcid:', '');
    // SUB format
    // cc-slas::zzrf_001::scid:c9c45bfd-0ed3-4aa2-xxxx-40f88962b836::usid:b4865233-de92-4039-xxxx-aa2dfc8c1ea5
    const usid = sub.split('::')[3].replace('usid:', '');
    return {
      isGuest,
      customerId,
      usid
    };
  }
}
var _default = exports.default = Auth;